import React from 'react';
import {
    AppRegistry,
    AsyncStorage,
    Platform
} from 'react-native';
import webstomp from './webstomp/webstomp';
import {DeviceEventEmitter} from 'react-native';
import {Config} from "./Config.js";
import RabbitMQ from "./RabbitMQModule";

if( Platform.OS === "android" )
    var PushNotification = require('react-native-push-notification');

export default class MessageHandler 
{
    constructor()
    {
        this.callbacks = {};

        if( Platform.OS === "android" )
        {
            PushNotification.configure({
                // (optional) Called when Token is generated (iOS and Android)
                onRegister: function(token) {
                    console.log( 'TOKEN:', token );
                },
            
                // (required) Called when a remote or local notification is opened or received
                onNotification: function(notification) {
                    console.log( 'NOTIFICATION:', notification );
                },
            
                // ANDROID ONLY: GCM Sender ID (optional - not required for local notifications, but is need to receive remote push notifications)
                senderID: "YOUR GCM SENDER ID",
            
                // IOS ONLY (optional): default: all - Permissions to register.
                permissions: {
                    alert: true,
                    badge: true,
                    sound: true
                },
            
                // Should the initial notification be popped automatically
                // default: true
                popInitialNotification: true,
            
                /**
                     * (optional) default: true
                    * - Specified if permissions (ios) and token (android and ios) will requested or not,
                    * - if not, you must call PushNotificationsHandler.requestPermissions() later
                    */
                requestPermissions: true,
            });
        }
    }

    static getInstance() 
    {
        if( this.instance === null || this.instance === undefined )
        {
            this.instance = new MessageHandler();
        }

        return this.instance;
    }

    init()
    {
        if (Platform.OS === "android") {
            this.androidSetup();
        } else {
            this.iosSetup();
        }
    }

    close()
    {
        console.log("CLOSING CONNECTIONS");
        if( Platform.OS === "android" )
        {
            RabbitMQ.close();
        }
        else
        {
            if (typeof this.client.close === "function") {
                this.client.close();
            }
        }
    }

    addListener(name, callback)
    {
        console.log("ADDING CALLBACK: " + name );
        this.callbacks[name] = callback;
    }

    removeListener(name)
    {
        console.log("REMOVING CALLBACK: " + name );
        delete this.callbacks[name];
    };

    addMessage = async(msg) => 
    {
        console.log("RECEIVED:");
        console.log(msg);
        var channelKey = msg.channel;
        var currentMessageID = await AsyncStorage.getItem( "@app_db:" + channelKey + "_" + "LAST_MESSAGE_ID" );

        var result = {
            key: new Date().valueOf(),
            date: new Date().getHours() + ":" + new Date().getMinutes() + ":" + new Date().getSeconds(),
            sender: msg.sender, 
            msg: msg.message,
            type : msg.message_type,
            img_identifier : msg.img_identifier,
            mime : msg.mime,
            location : msg.message_type === Config.MessageType.LOCATION_MESSAGE ? JSON.parse(msg.location) : ""
        };

        if( this.callbacks[channelKey] !== undefined )
            this.callbacks[channelKey](result);
        else
        {
            if( Platform.OS === "android" )
            {
                PushNotification.localNotification({
                    /* Android Only Properties */
                    id: '0', // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
                    ticker: "My Notification Ticker", // (optional)
                    autoCancel: true, // (optional) default: true
                    largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
                    smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
                    bigText: "figChat", // (optional) default: "message" prop
                    subText: "figChat - " + msg.sender, // (optional) default: none
                    vibrate: true, // (optional) default: true
                    vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
                    tag: 'msg_rec', // (optional) add tag to message
                    group: "group", // (optional) add group to message
                    ongoing: false, // (optional) set whether this is an "ongoing" notification
                            
                    /* iOS and Android properties */
                    title: "figChat", // (optional, for iOS this is only used in apple watch, the title will be the app name on other iOS devices)
                    message: msg.message, // (required)
                    playSound: false, // (optional) default: true
                    soundName: 'default', // (optional) Sound to play when the notification is shown. Value of 'default' plays the default sound. It can be set to a custom sound such as 'android.resource://com.xyz/raw/my_sound'. It will look for the 'my_sound' audio file in 'res/raw' directory and play it. default: 'default' (default sound is played)
                });
            }
        }

        // TODO: else: chat is not visible, show a notification.

        currentMessageID = Number(currentMessageID);

        try
        {
            await AsyncStorage.setItem( "@app_db:" + channelKey + "_" + "LAST_MESSAGE", JSON.stringify(result) );
            await AsyncStorage.setItem( "@app_db:" + channelKey + "_" + currentMessageID, JSON.stringify(result) );
            await AsyncStorage.setItem( "@app_db:" + channelKey + "_" + "LAST_MESSAGE_ID", "" +(currentMessageID + 1) );
        }
        catch( err )
        {
            console.log( "Failed to save msg" );
            console.log( err );
        }
    };

    sendMessage = async(msg, channelKey, clients) =>
    {
        const username = await AsyncStorage.getItem('@app_db:username');
        
        const envelope = JSON.stringify({
            message_type : msg.type,
            sender: username,
            channel: channelKey,
            message: msg.msg,
            img_identifier : msg.imageIdentifier,
            mime : msg.mime,
            signature: "abc",
            location : msg.location
        });

        console.log(envelope);

        clients.forEach((c) => {

        if (Platform.OS === "android") {
            return RabbitMQ.sendMessage(envelope, c.identifierKey);
        } else {
            if (typeof this.client.send !== "function"|| !this.client.connected) {
                this.iosSetup();
            }
            this.client.send('/exchange/messages/' + c.identifierKey, envelope);
        }
        
        });
    }

    iosSetup() {
        this.ws = new WebSocket('ws://' + Config.SOCKET_URL + '/ws');
        this.client = webstomp.over(this.ws);

        if (!this.client.connected) {
            this.client.connect('client', 'xdkBeWTwYGv3h1s', async () => {
                console.log("CONNECTION OPENED");

                AsyncStorage.getItem('@app_db:clientKey').then( (key) => {
                    console.log("SUBSCRIBED TO QUEUE");
                    var sub = this.client.subscribe("/amq/queue/" + key, (d) => {
                        this.addMessage(JSON.parse(d.body));
                    });
                } ).catch( (err) => {
                    console.log( err );
                });
            }, (err) =>{
                console.log("FAILED TO CONNECT");
                console.log(err);
            }, '/');
        }
    };

    androidSetup = async () => {
        const key = await AsyncStorage.getItem('@app_db:clientKey');

        console.log(key);

        try {
            await RabbitMQ.init("client", "xdkBeWTwYGv3h1s", "notes.ipieter.be", 5672, "/");
            await RabbitMQ.declareExchange("messages");
            await RabbitMQ.subscribe(key);
        } catch (err) {
            console.log(err);
        }

        DeviceEventEmitter.addListener('messageReceived', (params) => {
            var d = params.message;
            this.addMessage( JSON.parse(d) );
        });
    };
}